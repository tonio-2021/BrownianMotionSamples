<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Domain Rendering Test</title>
  <style>
    body {
      margin: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 90vh;
      background-color: #f0f0f0;
      font-family: sans-serif;
    }
    canvas {
      border: 1px solid #555;
      background-color: #fff;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    #errorMessage {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #ffdddd;
      color: #d8000c;
      padding: 10px;
      border: 1px solid #d8000c;
      border-radius: 5px;
      display: none; /* Standardmäßig versteckt */
    }
  </style>
</head>
<body>
  <canvas id="domainCanvas" width="600" height="600"></canvas>
  <div id="errorMessage"></div>

  <script>
    // ---------- Canvas-Konstanten ----------
    const canvas = document.getElementById('domainCanvas');
    const ctx = canvas.getContext('2d');
    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;
    const errorMessageDiv = document.getElementById('errorMessage');

    // ---------- Geometrie-Parameter ----------
    const R     = 0.4;   // Kreisradius
    const D     = 0.7;   // Abstand der Kreismittelpunkte (C1 bis C2)
    const G_W   = 0.08;  // Gangbreite (Korridorbreite)

    // Mittelpunkte der Kreise (Weltkoordinaten)
    // C1 ist links, C2 ist rechts, wenn D positiv
    const C1 = [ -D / 2, 0 ]; // Mittelpunkt linker Kreis
    const C2 = [  D / 2, 0 ]; // Mittelpunkt rechter Kreis

    // Skalierungsfaktor und Transformationsfunktionen
    const SCALE = WIDTH * 0.45; // Skaliert Weltkoordinaten auf Canvas-Pixel

    // Konvertiert Welt-x in Canvas-x
    const toX = worldX => WIDTH / 2  + worldX * SCALE;
    // Konvertiert Welt-y in Canvas-y (y-Achse im Canvas ist invertiert)
    const toY = worldY => HEIGHT / 2 - worldY * SCALE;

    // ---------- Funktion zum Zeichnen des Domain-Gebiets ----------
    function drawDomain() {
      ctx.clearRect(0, 0, WIDTH, HEIGHT); // Canvas leeren

      // Zeichenstile
      ctx.lineWidth   = 3;          // Linienbreite für den Rand
      ctx.strokeStyle = '#FF0000';  // Randfarbe (Rot für gute Sichtbarkeit)
      ctx.fillStyle   = '#E0E0E0';  // Füllfarbe des Gebiets (Hellgrau)

      const halfH = G_W / 2; // Halbe Gangbreite

      // Überprüfung der geometrischen Gültigkeit
      if (halfH >= R) {
        const errorMsg = `Geometrie ungültig: Gangbreite (G_W=${G_W}) ist zu groß für den Kreisradius (R=${R}). Der Gang darf nicht breiter als der Durchmesser sein.`;
        console.error(errorMsg);
        errorMessageDiv.textContent = errorMsg;
        errorMessageDiv.style.display = 'block';
        // Optional: Einen Hinweis auf dem Canvas zeichnen
        ctx.font = "14px Arial";
        ctx.fillStyle = "blue";
        ctx.textAlign = "center";
        ctx.fillText("Geometrie ungültig: G_W zu groß.", WIDTH/2, HEIGHT/2 - 20);
        ctx.fillText(`G_W (${G_W.toFixed(3)}) >= R (${R.toFixed(3)})`, WIDTH/2, HEIGHT/2);
        return; // Zeichnen abbrechen
      }
      errorMessageDiv.style.display = 'none'; // Fehlermeldung ausblenden, falls vorher sichtbar

      // Berechnung von dxCut: x-Distanz vom Kreismittelpunkt zum Punkt,
      // an dem der Kreisbogen in den geraden Gang übergeht.
      // Basiert auf dem Satz des Pythagoras: R^2 = dxCut^2 + halfH^2
      const R_squared = R * R;
      const halfH_squared = halfH * halfH;
      const dxCut_squared = R_squared - halfH_squared;

      if (dxCut_squared < 0) { // Sollte durch halfH >= R abgedeckt sein, aber als extra Sicherheit
        const errorMsg = `Fehler bei der Berechnung: dxCut_squared (${dxCut_squared.toFixed(3)}) ist negativ. R=${R}, halfH=${halfH}.`;
        console.error(errorMsg);
        errorMessageDiv.textContent = errorMsg;
        errorMessageDiv.style.display = 'block';
        ctx.font = "14px Arial";
        ctx.fillStyle = "orange";
        ctx.textAlign = "center";
        ctx.fillText("Berechnungsfehler für dxCut.", WIDTH/2, HEIGHT/2);
        return; // Zeichnen abbrechen
      }
      const dxCut = Math.sqrt(dxCut_squared);

      // Koordinaten der "Eckpunkte" des Gangs (Weltkoordinaten)
      // TR = Top-Right, TL = Top-Left, BR = Bottom-Right, BL = Bottom-Left
      // Bezogen auf den jeweiligen Kreis und die Öffnung des Gangs
      const P_C1_TR_x = C1[0] + dxCut; // Öffnung des linken Kreises, oben rechts
      const P_C1_TR_y = halfH;
      const P_C2_TL_x = C2[0] - dxCut; // Öffnung des rechten Kreises, oben links
      const P_C2_TL_y = halfH;

      const P_C1_BR_x = C1[0] + dxCut; // Öffnung des linken Kreises, unten rechts
      const P_C1_BR_y = -halfH;
      const P_C2_BL_x = C2[0] - dxCut; // Öffnung des rechten Kreises, unten links
      const P_C2_BL_y = -halfH;

      // Winkel für die Kreisbögen (benötigt für ctx.arc)
      // Winkel werden von der positiven x-Achse gegen den Uhrzeigersinn gemessen.
      // Math.atan2(y, x) gibt den Winkel in Radiant zurück.
      const ang_C1_TR = Math.atan2(P_C1_TR_y - C1[1], P_C1_TR_x - C1[0]); // Startwinkel für Bogen C1 (unten) -> Endwinkel (oben)
      const ang_C1_BR = Math.atan2(P_C1_BR_y - C1[1], P_C1_BR_x - C1[0]);

      const ang_C2_TL = Math.atan2(P_C2_TL_y - C2[1], P_C2_TL_x - C2[0]); // Startwinkel für Bogen C2 (oben) -> Endwinkel (unten)
      const ang_C2_BL = Math.atan2(P_C2_BL_y - C2[1], P_C2_BL_x - C2[0]);

      // Pfadkonstruktion mit direkten Kontextmethoden
      ctx.beginPath(); // Neuen Pfad beginnen

      // Vom oberen rechten Punkt der C1-Öffnung
      ctx.moveTo(toX(P_C1_TR_x), toY(P_C1_TR_y));
      // Linie zum oberen linken Punkt der C2-Öffnung
      ctx.lineTo(toX(P_C2_TL_x), toY(P_C2_TL_y));
      // Kreisbogen für den rechten Kreis (C2)
      // arc(x, y, radius, startAngle, endAngle, anticlockwise)
      // Wir zeichnen den äußeren Bogen im Uhrzeigersinn (anticlockwise = false)
      ctx.arc(toX(C2[0]), toY(C2[1]), R * SCALE, ang_C2_TL, ang_C2_BL, false);
      // Linie zum unteren rechten Punkt der C1-Öffnung (durch C2s unteren linken Punkt)
      ctx.lineTo(toX(P_C1_BR_x), toY(P_C1_BR_y));
      // Kreisbogen für den linken Kreis (C1)
      ctx.arc(toX(C1[0]), toY(C1[1]), R * SCALE, ang_C1_BR, ang_C1_TR, false);

      ctx.closePath(); // Pfad schließen (verbindet aktuellen Punkt mit Startpunkt)

      // Form füllen und Rand zeichnen
      ctx.fill();
      ctx.stroke();

      // console.log("Domain gezeichnet.");
      // console.log(`C1: [${C1[0]}, ${C1[1]}], C2: [${C2[0]}, ${C2[1]}]`);
      // console.log(`P_C1_TR: [${P_C1_TR_x.toFixed(3)}, ${P_C1_TR_y.toFixed(3)}], P_C2_TL: [${P_C2_TL_x.toFixed(3)}, ${P_C2_TL_y.toFixed(3)}]`);
      // console.log(`P_C1_BR: [${P_C1_BR_x.toFixed(3)}, ${P_C1_BR_y.toFixed(3)}], P_C2_BL: [${P_C2_BL_x.toFixed(3)}, ${P_C2_BL_y.toFixed(3)}]`);
      // console.log(`ang_C1_BR: ${ang_C1_BR.toFixed(3)} rad, ang_C1_TR: ${ang_C1_TR.toFixed(3)} rad`);
      // console.log(`ang_C2_TL: ${ang_C2_TL.toFixed(3)} rad, ang_C2_BL: ${ang_C2_BL.toFixed(3)} rad`);
    }

    // ---------- Initiales Rendering ----------
    // Rufen Sie die Zeichenfunktion auf, um die Domain beim Laden der Seite darzustellen.
    drawDomain();

    // Sie können hier die Geometrieparameter ändern und drawDomain() erneut aufrufen,
    // um die Änderungen zu sehen, z.B. in der Browser-Konsole:
    // R = 0.3; D = 0.5; G_W = 0.1; drawDomain();
    // G_W = 0.81; drawDomain(); // Beispiel für ungültige Geometrie

  </script>
</body>
</html>